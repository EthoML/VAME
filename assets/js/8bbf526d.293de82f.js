"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7622],{9599:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>a,frontMatter:()=>i,metadata:()=>o,toc:()=>d});var s=r(4848),t=r(8453);const i={sidebar_label:"tree_hierarchy",title:"analysis.tree_hierarchy"},l=void 0,o={id:"reference/analysis/tree_hierarchy",title:"analysis.tree_hierarchy",description:"hierarchy\\_pos",source:"@site/docs/reference/analysis/tree_hierarchy.md",sourceDirName:"reference/analysis",slug:"/reference/analysis/tree_hierarchy",permalink:"/VAME/docs/reference/analysis/tree_hierarchy",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{sidebar_label:"tree_hierarchy",title:"analysis.tree_hierarchy"},sidebar:"docsSidebar",previous:{title:"pose_segmentation",permalink:"/VAME/docs/reference/analysis/pose_segmentation"},next:{title:"umap",permalink:"/VAME/docs/reference/analysis/umap"}},c={},d=[{value:"hierarchy_pos",id:"hierarchy_pos",level:4},{value:"merge_func",id:"merge_func",level:4},{value:"graph_to_tree",id:"graph_to_tree",level:4},{value:"draw_tree",id:"draw_tree",level:4},{value:"_traverse_tree_cutline",id:"_traverse_tree_cutline",level:4},{value:"traverse_tree_cutline",id:"traverse_tree_cutline",level:4},{value:"bag_nodes_by_cutline",id:"bag_nodes_by_cutline",level:4}];function h(e){const n={a:"a",code:"code",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h4,{id:"hierarchy_pos",children:"hierarchy_pos"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def hierarchy_pos(G: nx.Graph,\n                  root: str | None = None,\n                  width: float = 0.5,\n                  vert_gap: float = 0.2,\n                  vert_loc: float = 0,\n                  xcenter: float = 0.5) -> Dict[str, Tuple[float, float]]\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Positions nodes in a tree-like layout.\nRef: From Joel's answer at ",(0,s.jsx)(n.a,{href:"https://stackoverflow.com/a/29597209/2966723",children:"https://stackoverflow.com/a/29597209/2966723"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"G"})," (",(0,s.jsx)(n.code,{children:"nx.Graph"}),"): The input graph. Must be a tree."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"root"})," (",(0,s.jsx)(n.code,{children:"str, optional"}),"): The root node of the tree. If None, the function selects a root node based on graph type.\nDefaults to None."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"width"})," (",(0,s.jsx)(n.code,{children:"float, optional"}),"): The horizontal space assigned to each level. Defaults to 0.5."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"vert_gap"})," (",(0,s.jsx)(n.code,{children:"float, optional"}),"): The vertical gap between levels. Defaults to 0.2."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"vert_loc"})," (",(0,s.jsx)(n.code,{children:"float, optional"}),"): The vertical location of the root node. Defaults to 0."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"xcenter"})," (",(0,s.jsx)(n.code,{children:"float, optional"}),"): The horizontal location of the root node. Defaults to 0.5."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Dict[str, Tuple[float, float]]"}),": A dictionary mapping node names to their positions (x, y)."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"merge_func",children:"merge_func"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def merge_func(transition_matrix: np.ndarray, n_clusters: int,\n               motif_norm: np.ndarray,\n               merge_sel: int) -> Tuple[np.ndarray, np.ndarray]\n"})}),"\n",(0,s.jsx)(n.p,{children:"Merge nodes in a graph based on a selection criterion."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"transition_matrix"})," (",(0,s.jsx)(n.code,{children:"np.ndarray"}),"): The transition matrix of the graph."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"n_clusters"})," (",(0,s.jsx)(n.code,{children:"int"}),"): The number of clusters."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"motif_norm"})," (",(0,s.jsx)(n.code,{children:"np.ndarray"}),"): The normalized motif matrix."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"merge_sel"})," (",(0,s.jsx)(n.code,{children:"int"}),"): The merge selection criterion."]}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"0: Merge nodes with highest transition probability."}),"\n",(0,s.jsx)(n.li,{children:"1: Merge nodes with lowest cost."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Tuple[np.ndarray, np.ndarray]"}),": A tuple containing the merged nodes."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"graph_to_tree",children:"graph_to_tree"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def graph_to_tree(motif_usage: np.ndarray,\n                  transition_matrix: np.ndarray,\n                  n_clusters: int,\n                  merge_sel: int = 1) -> nx.Graph\n"})}),"\n",(0,s.jsx)(n.p,{children:"Convert a graph to a tree."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"motif_usage"})," (",(0,s.jsx)(n.code,{children:"np.ndarray"}),"): The motif usage matrix."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"transition_matrix"})," (",(0,s.jsx)(n.code,{children:"np.ndarray"}),"): The transition matrix of the graph."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"n_clusters"})," (",(0,s.jsx)(n.code,{children:"int"}),"): The number of clusters."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"merge_sel"})," (",(0,s.jsx)(n.code,{children:"int, optional"}),"): The merge selection criterion. Defaults to 1."]}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"0: Merge nodes with highest transition probability."}),"\n",(0,s.jsx)(n.li,{children:"1: Merge nodes with lowest cost."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"nx.Graph"}),": The tree."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"draw_tree",children:"draw_tree"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def draw_tree(\n    T: nx.Graph,\n    fig_width: float = 200.0,\n    usage_dict: Dict[str, float] = dict()) -> None\n"})}),"\n",(0,s.jsx)(n.p,{children:"Draw a tree."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"T"})," (",(0,s.jsx)(n.code,{children:"nx.Graph"}),"): The tree to be drawn."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"fig_width"})," (",(0,s.jsx)(n.code,{children:"int, optional"}),"): The width of the figure. Defaults to 10."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"None"})}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"_traverse_tree_cutline",children:"_traverse_tree_cutline"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def _traverse_tree_cutline(\n        T: nx.Graph,\n        node: List[str],\n        traverse_list: List[str],\n        cutline: int,\n        level: int,\n        community_bag: List[List[str]],\n        community_list: List[str] = None) -> List[List[str]]\n"})}),"\n",(0,s.jsx)(n.p,{children:"DEPRECATED in favor of bag_nodes_by_cutline.\nHelper function for tree traversal with a cutline."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"T"})," (",(0,s.jsx)(n.code,{children:"nx.Graph"}),"): The tree to be traversed."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"node"})," (",(0,s.jsx)(n.code,{children:"List[str]"}),"): Current node being traversed."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"traverse_list"})," (",(0,s.jsx)(n.code,{children:"List[str]"}),"): List of traversed nodes."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"cutline"})," (",(0,s.jsx)(n.code,{children:"int"}),"): The cutline level."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"level"})," (",(0,s.jsx)(n.code,{children:"int"}),"): The current level in the tree."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"community_bag"})," (",(0,s.jsx)(n.code,{children:"List[List[str]]"}),"): List of community bags."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"community_list"})," (",(0,s.jsx)(n.code,{children:"List[str], optional"}),"): List of nodes in the current community bag."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"List[List[str]]"}),": List of lists community bags."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"traverse_tree_cutline",children:"traverse_tree_cutline"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def traverse_tree_cutline(T: nx.Graph,\n                          root_node: str | None = None,\n                          cutline: int = 2) -> List[List[str]]\n"})}),"\n",(0,s.jsx)(n.p,{children:"DEPRECATED in favor of bag_nodes_by_cutline.\nTraverse a tree with a cutline and return the community bags."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"T"})," (",(0,s.jsx)(n.code,{children:"nx.Graph"}),"): The tree to be traversed."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"root_node"})," (",(0,s.jsx)(n.code,{children:"str, optional"}),"): The root node of the tree. If None, traversal starts from the root."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"cutline"})," (",(0,s.jsx)(n.code,{children:"int, optional"}),"): The cutline level."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"List[List[str]]"}),": List of community bags."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"bag_nodes_by_cutline",children:"bag_nodes_by_cutline"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def bag_nodes_by_cutline(tree: nx.Graph, cutline: int = 2, root: str = "Root")\n'})}),"\n",(0,s.jsx)(n.p,{children:"Bag nodes of a tree by a cutline."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"tree"})," (",(0,s.jsx)(n.code,{children:"nx.Graph"}),"): The tree to be bagged."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"cutline"})," (",(0,s.jsx)(n.code,{children:"int, optional"}),"): The cutline level. Defaults to 2."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"root"})," (",(0,s.jsx)(n.code,{children:"str, optional"}),"): The root node of the tree. Defaults to 'Root'."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"List[List[str]]"}),": List of bags of nodes."]}),"\n"]})]})}function a(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>o});var s=r(6540);const t={},i=s.createContext(t);function l(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);